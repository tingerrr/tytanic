//! Version control support, this is used in a project to ensure that ephemeral
//! storage directories are not managed by the VCS of the user. Currently
//! supports `.gitignore` and `.hgignore` based VCS' as well as auto discovery
//! of Git, Mercurial and Jujutsu through their hidden repository directories.

use std::fmt::{self, Debug, Display};
use std::path::{Path, PathBuf};
use std::{fs, io};

use crate::stdx;
use crate::stdx::result::ResultEx;

/// The name of the git ignore file.
const GITIGNORE_NAME: &str = ".gitignore";

/// The content of the generated git ignore file.
const GITIGNORE_CONTENT: &str = "# generated by typst-test, do not edit\n**\n";

/// The name of the mercurial ignore file.
const HGIGNORE_NAME: &str = ".hgignore";

/// The content of the generated mercurial ignore file.
const HGIGNORE_CONTENT: &str = "# generated by typst-test, do not edit\nregex: glob\n**\n";

/// The kind of [`Vcs`] in use.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Kind {
    /// Uses `.gitignore` files to ignore ephemeral storage directories.
    ///
    /// This means it can also be used by Vcs' which support `.gitignore` files,
    /// like Jujutsu.
    Git,

    /// Uses `.hgignore` files to ignore ephemeral storage directories.
    ///
    /// This means it can also be used by Vcs' which support `.hgignore` files.
    Mercurial,
}

/// A version control system, this is used to handle persistent storage of
/// reference images and ignoring of non-persistent directories like the `out`
/// and `diff` directories.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Vcs {
    root: PathBuf,
    kind: Kind,
}

impl Vcs {
    /// Creates a new Vcs with the given root directory and kind.
    pub fn new<I>(root: I, kind: Kind) -> Self
    where
        I: Into<PathBuf>,
    {
        Self {
            root: root.into(),
            kind,
        }
    }

    /// Checks the given directory for a Vcs, returning it a vcs is rooted here.
    pub fn try_new(root: &Path) -> io::Result<Option<Self>> {
        if root.join(".git").try_exists()? && root.join(".jj").try_exists()? {
            Ok(Some(Self::new(root, Kind::Git)))
        } else if root.join(".hg").try_exists()? {
            Ok(Some(Self::new(root, Kind::Mercurial)))
        } else {
            Ok(None)
        }
    }
}

impl Vcs {
    /// The root of this Vcs' repository.
    pub fn root(&self) -> &Path {
        &self.root
    }

    /// The kind of this repository.
    pub fn kind(&self) -> Kind {
        self.kind
    }

    /// Ignore the given directory.
    pub fn ignore_dir(&self, path: &Path) -> io::Result<()> {
        match self.kind {
            Kind::Git => {
                let gitignore = path.join(GITIGNORE_NAME);
                stdx::fs::create_dir(path, true)?;
                fs::write(gitignore, GITIGNORE_CONTENT)?;
            }
            Kind::Mercurial => {
                let hgignore = path.join(HGIGNORE_NAME);
                stdx::fs::create_dir(path, true)?;
                fs::write(hgignore, HGIGNORE_CONTENT)?;
            }
        }

        Ok(())
    }

    /// Unignore the given directory.
    pub fn unignore_dir(&self, path: &Path) -> io::Result<()> {
        match self.kind {
            Kind::Git => {
                let gitignore = path.join(GITIGNORE_NAME);
                fs::remove_file(gitignore).ignore(|e| e.kind() == io::ErrorKind::NotFound)?;
            }
            Kind::Mercurial => {
                let hgignore = path.join(HGIGNORE_NAME);
                fs::remove_file(hgignore).ignore(|e| e.kind() == io::ErrorKind::NotFound)?;
            }
        }

        Ok(())
    }
}

impl Display for Vcs {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.pad(match self.kind {
            Kind::Git => "Git",
            Kind::Mercurial => "Mercurial",
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::_dev;
    use crate::project::test::Id;
    use crate::project::Paths;

    #[test]
    fn test_git_ignore_dir_create() {
        _dev::fs::TempEnv::run(
            |root| root.setup_dir("tests/fancy/out"),
            |root| {
                let paths = Paths::new(root, None);
                let vcs = Vcs::new(root, Kind::Git);
                vcs.ignore_dir(&paths.test_out_dir(&Id::new("fancy").unwrap()))
                    .unwrap();
            },
            |root| {
                root.expect_dir("tests/fancy/out")
                    .expect_file_content("tests/fancy/out/.gitignore", GITIGNORE_CONTENT)
            },
        );
    }

    #[test]
    fn test_git_ignore_dir_truncate() {
        _dev::fs::TempEnv::run(
            |root| {
                root.setup_dir("tests/fancy/out")
                    .setup_file("tests/fancy/out/.gitignore", "blah blah")
            },
            |root| {
                let paths = Paths::new(root, None);
                let vcs = Vcs::new(root, Kind::Git);
                vcs.ignore_dir(&paths.test_out_dir(&Id::new("fancy").unwrap()))
                    .unwrap();
            },
            |root| {
                root.expect_dir("tests/fancy/out")
                    .expect_file_content("tests/fancy/out/.gitignore", GITIGNORE_CONTENT)
            },
        );
    }

    #[test]
    fn test_git_unignore_dir_no_op() {
        _dev::fs::TempEnv::run(
            |root| root.setup_dir("tests/fancy/out"),
            |root| {
                let paths = Paths::new(root, None);
                let vcs = Vcs::new(root, Kind::Git);
                vcs.unignore_dir(&paths.test_out_dir(&Id::new("fancy").unwrap()))
                    .unwrap();
            },
            |root| root.expect_dir("tests/fancy/out"),
        );
    }

    #[test]
    fn test_git_unignore_dir_remove() {
        _dev::fs::TempEnv::run(
            |root| {
                root.setup_dir("tests/fancy/out")
                    .setup_file("tests/fancy/out/.gitignore", "blah blah")
            },
            |root| {
                let paths = Paths::new(root, None);
                let vcs = Vcs::new(root, Kind::Git);
                vcs.unignore_dir(&paths.test_out_dir(&Id::new("fancy").unwrap()))
                    .unwrap();
            },
            |root| root.expect_dir("tests/fancy/out"),
        );
    }
}
